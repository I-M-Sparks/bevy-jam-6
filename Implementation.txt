Kenney-packs that fit "Rune Goldberg Machine" (potentially):
-Particle Pack
-Smoke Particles
-Physics assets
-Platformer Art Requests
-Puzzle Pack
-Pixel UI Pack
-Puzzle Pack 2
-Animal Pack
-Letter tiles
-Generic items
-Ranks Pack
-Crosshair Pack
-Simplified Platformer
-Roling Ball Assets
-Foliage sprites
-Emotes pack
-Splat Pack
-Rune Pack
-Shape Characters
-Cursor Pack
-Googly eyes
-Board game Icons

First steps:
-create window - DONE
-Render runes - DONE
-implement click & release - DONE
-implement drag & drop - DONE
--get cursor position on click/release - DONE

-figure out how to place sprite in specific position - DONE
-figure out how to change window size - CANCELLED; Window size is 1280 x 720, which is fine
-figure out how to render multiple assets - DONE
+++
next step: Prototype
-build for WASM/web (check playability)
-implement one rune magic effect (move in zero gravity single direction)
-implement start of chain reaction (including test attempts / final attempt logic)
-implement one follow up effect based on placed rune (triggered by the end of the previous effect)
--figure out how to detect "collision"
-enable/disable player input before-and-after/during chain reaction
-figure out how to track when a machine has reached it's conclusion (both success and failure)

goal: enable player to set up a single chain reaction with at least two components and play on web, with a detected failure/success

++++

FixedUpdate vs Update

moved the function that places the currently Picked object on the mouse cursor to a separate system which runs on Update, not FixedUpdate
-> feels much smoother

+++

Single-Queries can be used as conditions for functions

by adding a Single Query like this:
Single<Entity, (With<ComponentA>, Without<ComponentB>)>

effectively, this means that the function containing this query will only run if there is an entity that holds A-and-not-B

now I can just create an entity that is used as a "meta-entity", for example a player entity that holds no visible game content

I used it to react to press/release events only if the player was marked with "PlayerAttemptsPress"/"PlayerAttemptsRelease"

+++

sprites

Sprites can be changed in size by using the custom_size field
their size can also be changed by using the scale in a transformn component (within the same entity, the sprite itself doesn't have a transform inside)
NOTE: when using both custom_size AND scale, they add up; so the end result-size is custom_size * scale

the z-component of the transform is used by the sprite as render-layer; 0 is the furthest in the back, higher numbers = further to the front
NOTE: when scaling the sprite, the z-component of the scale has no effect (aka does not change a sprites render layer)

+++